“次结构类型系统”会在常见类型系统的基础上，取消下列性质的一个或者多个：

Exchange: ![alt text](image.png)

Weakening: ![alt text](image-1.png)

Contraction: ![alt text](image-2.png)

| 规则        | 变量使用次数         | 允许的操作      |
|-------------|----------------------|-----------------|
| Linear      | = 1                  | E               |
| Affine      | ≤ 1                  | E, W            |
| Relevant    | ≥ 1                  | E, C            |
| Ordered     | = 1，且按引入的顺序  | 无              |

Syntax: 

![alt text](image-3.png)


![alt text](image-4.png)

以下是Context Split的定义，翻译成人话：

0. 空context在split后产生2个空context
1. un变量在split时会复制到左右两边。
2. lin变量在split时要不划给左边，要不划给右边。

具体怎么split，没说！(见下文)

下面是Typing规则保证的2个不变式：

1. lin变量在任何路径使用次数=1
2. un项不包含lin项

以下是Typing 规则，注意Context split并未给出具体算法，只是说明存在Γ1，Γ2， Γ1 o Γ2 = Γ ，使得 Typing 成立。

![alt text](image-5.png)
在Typing 的过程中，始终坚持保证**一个lin变量只能使用1次**。例如在T-APP中，
t1 得到了 上下文 Γ1，t2 得到了 上下文 Γ2。根据context split的定义，Γ1和Γ2中的lin变量不重叠，所以不会存在t1使用t2中lin 变量的现象。

此外还要确保**没有lin变量没有用到**，例如T-VAR中，检查了x:T以外的context不包含lin变量。T-BOOL也是。


下面介绍如何执行context split：

首先：定义 “context difference”,用除号表示

![alt text](image-7.png)

人话：

- 除以 lin P = (1) 检查 Γ1 **无** 此 lin P，违反则报错 (2) 结果为 Γ1 

- 除以 un P = (1) 检查 Γ1 **有** 此 un P，违反则报错 (2) 结果为 Γ1 - { un P }

- 除以一个集合的结果为执行所有除数对应的检查，并删除对应的 un P 作为结果。

这个玩意引入的目的是(1)检查 lin 变量真的被使用了，(2)删除 un 变量。后续每条规则都要记得关注这2个性质。

然后，定义算法版 typing rule：

![alt text](image-8.png)


所有规则都是吃进去一个 Γ1 ，吐出来一个 Γ2 。可以理解为
 Γ2 - Γ1 就是表达式捕获并消化掉的变量。这里上下文Γ可以理解为是一些语言中 lambda 闭包捕获到的变量。
 
  - 规则 A-UVAR：un 变量 无法消化

  - 规则 A-LVAR: lin 变量使用一次后就消化掉了

当表达式有子结构时，往往先把 Γ1 喂给子结构1，吐出来一个 Γ2，再把 Γ2 喂给子结构2，以此类推。（参见 IF、PAIR ）。

重点来了，un 项/类型不能包含 lin 项或者类型。因为 un 可以用 无限次，包含lin的话那间接也用了 lin 多次。

- 算包含的：元组、闭包捕获的变量。

- 不算包含的：un 函数的 lin 参数。因为参数是 lin  类型但是你每次调用函数都会提供一个新的参数。所以多次调用无所谓。

那我如何检查这个呢？元组使用 q(T1) q(T2) 检查。当 q=un 时， un(T) 会检查 T 里面不含 lin 类型。

函数闭包则采用一个在 q=un （函数是 un ） 时才执行 Γ1  = Γ2 ÷ (x:T1) 的检查。

这个规则分2种情况


  -  参数 x 是 lin : 将捕获的变量 Γ1 和参数 x 一并交给函数体 t2，并检查吐出来的 Γ2 。Γ1  = Γ2 ÷ (x:T1) 此时确保 Γ2 中无 x ，也就是 lin 参数 x 已经被使用掉了。（你的参数，你不用也没人能用了，没人用那就违反lin的规则了）**此时如果函数使用了 Γ1 中的 lin 变量 y（即，必须捕获这个 y），则 Γ2 ÷ (x:T1) 相比 Γ1 会少掉 y。** 检查会不通过。

  - 参数 x 是 un ： 同样是检查吐出来的 Γ2 。这次是检查Γ2 中有 x ，因为 un 变量无法被消化，当时吃进去的现在还得拉出来，所以肯定还在。闭包的输出Γ为 Γ2 ÷ (x:T1) = Γ2 - {x:T1}，为啥要删掉x？因为闭包外面访问不了x。


所有检查变量至少使用1次的地方被移动到了变量引入处：

A-SPLIT： 引入了x,y 所以 Γ3 / (x:T1, y:T2) 检查x,y都被使用掉了。

A-ABS：引入了x 所以 Γ2 / (x:T1) 检查 x 被使用掉了。

